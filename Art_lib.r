#+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°
# Libraries 
#+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°

library(deSolve)
library(baseline)
library(MASS)
library(devEMF)
library(segmented)
library(sfsmisc)
library(smoother)
library(pracma)
library(data.table)
library(broom)
library(openxlsx)
library(minpack.lm) #nls does not work
library(ggplot2)
library(gridExtra)
library(RColorBrewer)
library(ggrepel)
library(kmlShape)
library(caret)
library(purrr)
library(dplyr)
library(tidyr)
library(nlstools)
library(patchwork)
library(takos)

#+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°
# Function for solving the DE modified from takos just for the add of 
# one coeff (same results as takos, just added for the output to be usable by 
# other function
#+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°

gAC<-  function (time.start, T0, T.end, qqq, A, Ea, co, m,n,K, npoints,   
				 prec,rmod="SB", ...)           
{
  R 		<- 8.314
  Ts 		<- 273.15+ T0  
  time.e 	<- (T.end - T0)/(qqq/60) 
  time.s=seq(time.start, time.e, length.out=npoints) 
  tm = time.s 
  Temp = Ts+(time.s*(qqq/60)) 
  fa <- switch(rmod,
			   "RO1"="((1-y1)^n)*((1+(K*y1))",
			   "RO2"="m*(1-y1)*((-log(1-y1))^(1-(1/m)))",
			   "RO3"="(1-y1)^n",
			   "SB"="co*y1^m*(1-y1)^n",
			   "P1"="4*y1^(3/4)",
			   "P2"="3*y1^(2/3)",
			   "P3"="2*y1^(1/2)",
			   "P4"="(2/3)*y1^-(1/2)",
			   "D1"="(0.5)/(y1)",
			   "F1"="1-y1",
			   "A4"="4*(1-y1)*((-log(1-y1))^(3/4))",
			   "A3"="3*(1-y1)*((-log(1-y1))^(2/3))",
			   "A2"="2*(1-y1)*((-log(1-y1))^(1/2))",
			   "D3"="((3/2)*(1-y1)^(2/3))*(1-(1-y1)^(1/3))^-1",
			   "D4"="(3/2)/(((1-y1)^(-1/3))-1)",
			   "R3"="3*(1-y1)^(2/3)",
			   "R2"="2(1-y1)^(1/2)",
			   "D2" ="-1/(log(1-y1))",
			   "JMA"="m*(1-y1)*((-log(1-y1))^(1-(1/m)))",
			   "Ih"="y1*(1-y1)",
			   "F2"="(1-y1)^2")
  SBf = function(tm, state, parms)  
{
		with(as.list(c(state, parms)),
		{  
		   a1_tm = Ts+(tm*qqq/60)   
		   dy1 =   A* exp(-Ea/(R*a1_tm))  * eval(parse(text=fa)) 
		   return(list(dy1,Temp = a1_tm, fi = dy1))           
		 }
	    )
	 }
rootfun  <- function(tm, y1, parms) {return(y1 - 1)}
state    <- c(y1 = prec) # 
P 		 <- list(Ts = Ts, qqq = qqq, A = A)       
sol		 <- ode(y = state, times = tm, parms = P, func = SBf, rootfun=rootfun,...) 
plot(sol) 
T.C    		<- Temp-273.15
T.K    		<- Temp
alfa   		<- c(sol[,2]*100)
y1     		<- c(sol[,2])
fi     		<- c(sol[,4])
dadT   		<- c(diff(y1)/diff((T.C)[1:length(y1)]))
my.list 	<- list("T.C" = T.C,"T.K" = T.K,
					"sol" = sol,"fi" = fi,
					"alfa" = alfa, "dadT"=dadT,
					"time.s"=time.s) 
return(my.list)
}

#+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°
# Extend gac adding a few columns derived from gAC does not "change" anything 
# from gAC (just multiplication and conversion of units)
#+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°

gACExt <- function(time.start, T0, T.end,
				  qqq, A, Ea,
				  co, m, n, K ,npoints,prec,rmod,...)
{
R <- 8.314
sim     <- gAC( time.start = time.start,
				T0 = T0, T.end = T.end,
			    qqq = qqq, A = A, Ea = Ea,
			    co=co, m=m, n=n, K=K,npoints=npoints,prec=prec,rmod=rmod,...)
sim$rates            				<- qqq
sim$id_cycle         				<- qqq
sim$time.minutes					<- sim$time.s/60
sim$time.minutes.zero				<- sim$time.s/60
sim$time.seconds.zero				<- sim$time.s
sim$ri 								<- sim$alfa/100
sim$dadt 							<- dadx(sim$time.minutes[1:length(sim$ri)],sim$ri)
sim$fa   							<- sim$dadt*exp(Ea/(R*sim$T.K[1:length(sim$dadt)]))
mylist <- list(
		"T.C" = sim$T.C, "T.K" = sim$T.K, "sol" = sim$sol, "fi" = sim$fi,
        "alfa" =  sim$alfa, "dadT" =  sim$dadT, "time.seconds" =  sim$time.s,
		"rates" = sim$rates,"id_cycle" =  sim$rates, "id" =  sim$rates,
		"time.minutes" = sim$time.minutes.zero, 
		"time.minutes.zero" = sim$time.minutes.zero,
		"time.seconds.zero" = sim$time.seconds.zero, "ri"= sim$ri,
		"dadt"= sim$dadt,"fa" = sim$fa)
return(mylist)
}

#+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°
# Create a batch of curves using gAC 
#+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°
batchac<- function(time.start,T0,T.end,rates,
				   A, Ea, co, 
				   m,
				   n,
				   npoints, prec, nres,rmod,...)
{
	#R  <- 8.314472       #iupac gold book gas constant
	R <- 8.314
	a0<-lapply(seq(1,length(rates)), function(x) gACExt(time.start=time.start,T0=T0,
			   T.end=T.end,qqq=rates[x],
			   A=A,Ea=Ea,co=co[x],m=m[x],n=n[x],
			   npoints=npoints,prec=prec,rmod=rmod,...))
	return(a0)
}

#+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°
# function that cut the extra points not needed for the calculation of EA 
# generated by the core function gAC.
# It takes the lentgh of fa, and set this and the max length also for all 
# the other variables  after cutting we put them back again together and we 
# also prepare a resampled version of the matrix
#+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°

peppa<-function(set){
maxl <- lapply(seq(1,length(set)), function(x) length(set[[x]]$fa))
#since rates and id cycle need padding we do not add the max lenght for them
lmod <- lapply(seq(1,length(set)),
		function(x) na.omit(data.table(
									  set[[x]]$T.C[1:unlist(maxl[x])],
									  set[[x]]$T.K[1:unlist(maxl[x])],
									  set[[x]]$time.seconds[1:unlist(maxl[x])], 
									  set[[x]]$time.seconds[1:unlist(maxl[x])],
									  set[[x]]$time.minutes[1:unlist(maxl[x])],
									  set[[x]]$time.minutes[1:unlist(maxl[x])],
									  set[[x]]$rates,	      
									  set[[x]]$id_cycle,
									  set[[x]]$id,
									  set[[x]]$fi[1:unlist(maxl[x])],
									  set[[x]]$alfa[1:unlist(maxl[x])],
									  set[[x]]$dadT[1:unlist(maxl[x])],
									  set[[x]]$dadT[1:unlist(maxl[x])],
									  set[[x]]$ri[1:unlist(maxl[x])],
									  set[[x]]$dadt[1:unlist(maxl[x])],
									  set[[x]]$fa[1:unlist(maxl[x])]
		   							  )))
						
colnames <- c("temperature.s", "temperature.s.K",
			  "time.seconds", "time.seconds.zero", "time.minutes", 
			  "time.minutes.zero", "rate", 
			  "id_cycle", "id", "fi", "alfa",
			  "heat.flow", "dadT", "ri", "dadt", "fa") 

lapply(lmod, setNames, colnames)
ap<- data.table(rbindlist(lmod))
colnames(ap) <- colnames
aptimemin<-ap[,(approx(ri,time.minutes,xout=seq(1/nrow(.SD),1,by=1/nrow(.SD)))),by=rate]
aptimesec<-ap[,(approx(ri,time.seconds,xout=seq(1/nrow(.SD),1,by=1/nrow(.SD)))),by=rate]
aptemps<-ap[,(approx(ri,temperature.s,xout=seq(1/nrow(.SD),1,by=1/nrow(.SD)))),by=rate]
aptempsK<-ap[,(approx(ri,temperature.s.K,xout=seq(1/nrow(.SD),1,by=1/nrow(.SD)))),by=rate]
aphf<-ap[,(approx(ri,heat.flow,xout=seq(1/nrow(.SD),1,by=1/nrow(.SD)))),by=rate]
apdadt<-ap[,(approx(ri,dadt,xout=seq(1/nrow(.SD),1,by=1/nrow(.SD)))),by=rate]
aptimeminz<-ap[,(approx(ri,time.minutes.zero,xout=seq(1/nrow(.SD),1,by=1/nrow(.SD)))),by=rate]
aptimesecz<-ap[,(approx(ri,time.seconds.zero,xout=seq(1/nrow(.SD),1,by=1/nrow(.SD)))),by=rate]
apfa<-ap[,(approx(ri,fa,xout=seq(1/nrow(.SD),1,by=1/nrow(.SD)))),by=rate]
apr<-data.table(aptimemin$y,    aptimesec$y,   aptemps$y,      aptempsK$y,
				aphf$y,     ap$id,ap$rate, apdadt$y, ap$id_cycle, aptimeminz$y,       aptimesec$y,apfa$y)
colnames(apr)=c("time.minutes","time.seconds","temperature.s","temperature.s.K",
				"heat.flow","id", "rate",  "dadt",  "id_cycle",  "time.minutes.zero","time.seconds.zero","fa")
apr[,ri:=seq(1/nrow(.SD),1,by=1/nrow(.SD)),by=rate]
my.list <- list("ap"=ap,"apr"=apr, "lmod"=lmod)
return(my.list)
}


#+++++++°+++++++++°°+++++++++°
#Prepare matrix for regression
#+++++++°+++++++++°°+++++++++°

sanitizeForReg <- function(set_in,low_lim_safe=2,up_lim_safe=2){

for (i in 1:length(set_in)){
		set_in[[i]]$T.C <- set_in[[i]]$T.C[low_lim_safe:(length(set_in[[i]]$T.C)-up_lim_safe)]
		set_in[[i]]$T.K <- set_in[[i]]$T.K[low_lim_safe:(length(set_in[[i]]$T.K)-up_lim_safe)]
		set_in[[i]]$fi <- set_in[[i]]$fi[low_lim_safe:(length(set_in[[i]]$fi)-up_lim_safe)]
		set_in[[i]]$alfa <- set_in[[i]]$alfa[low_lim_safe:(length(set_in[[i]]$alfa)-up_lim_safe)]
		set_in[[i]]$dadT <- set_in[[i]]$dadT[low_lim_safe:(length(set_in[[i]]$dadT)-up_lim_safe)]
		set_in[[i]]$time.seconds <- set_in[[i]]$time.seconds[low_lim_safe:(length(set_in[[i]]$time.seconds)-up_lim_safe)]
		set_in[[i]]$time.minutes <- set_in[[i]]$time.minutes[low_lim_safe:(length(set_in[[i]]$time.minutes)-up_lim_safe)]
		set_in[[i]]$time.minutes.zero <- set_in[[i]]$time.minutes.zero[low_lim_safe:(length(set_in[[i]]$time.minutes.zero)-up_lim_safe)]
		set_in[[i]]$time.seconds.zero <- set_in[[i]]$time.seconds.zero[low_lim_safe:(length(set_in[[i]]$time.seconds.zero)-up_lim_safe)]
		set_in[[i]]$ri <- set_in[[i]]$ri[low_lim_safe:(length(set_in[[i]]$ri)-up_lim_safe)]
		set_in[[i]]$dadt <- set_in[[i]]$dadt[low_lim_safe:(length(set_in[[i]]$dadt)-up_lim_safe)]
		set_in[[i]]$fa <- set_in[[i]]$fa[low_lim_safe:(length(set_in[[i]]$fa)-up_lim_safe)]
		}
set_sanitized <- set_in
return(set_sanitized)
}

#+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°
# Calculates EA with different methods (all from takos)
#+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°
batchtriplet <- function(ap,mydegree=seq(0.5,0.95,0.01)) {
#mydegree <- seq(0.005, 0.995, by = mystep)
aF <- FRI(ap,degree=mydegree)
aKAS <- KAS(ap,degree=mydegree)
aStarink <- Starink(ap,degree=mydegree)
aOFW <- OFW(ap,degree=mydegree)
aOZ <- OZ(ap,n.step=1, spks=1, eps=0.001)
aKiss <- Kiss(ap)
Ea.res <- data.table(mydegree,unlist(aF$Ea),unlist(aKAS$Ea),unlist(aStarink$Ea),unlist(aKiss$Ea))
colnames(Ea.res)=c("degree","Friedman","KAS","Starink","Kissinger")
Ea.res=data.table(Ea.res)
my.list <- list("F"=aF,"KAS"=aKAS,"Star"=aStarink,"OFW"=aOFW,"OZ"=aOZ,"Kiss"=aKiss,"EA"=Ea.res)
return(my.list)
}

#+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°
# Calculates simulated curves one function is just for the ground truth 
# (just for clarity sake)
#+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°

create_set_gt <- function(time.s, Ts, TE, AA, E, qq, np, pr, refMod, deg,amin,amax,...) {
 
set_gt            <- batchac(time.start=time.s,T0 = Ts, T.end = TE, A = AA, Ea = E, rates = qq, 
					 co = 1,m = 1, n = 1, K = 0, npoints = np, prec = pr, rmod = refMod,...)
set_gt 		  	  <- sanitizeForReg(set_gt)
set_gt_ap         <- peppa(set_gt)
dat_gt 			  <- set_gt_ap$ap
dat_gt_r         <- set_gt_ap$apr
dat_gt_r$set         <- refMod

dat_gt$a   <- dat_gt$alfa/100
dat_gt$fan <- (dat_gt$fa)/max(dat_gt$fa)
dat_gt$set <- refMod
dat_gt <- dat_gt[,c("id_cycle","id"):=NULL]

dat_gt_sel <- subset(dat_gt, (a >=amin & a <=amax))


mylist=list("set_gt"=set_gt,
			"dat_gt"=dat_gt,
			"dat_gt_r"=dat_gt_r,
			"dat_gt_sel"=dat_gt_sel)

return(mylist)
}


create_set <- function(nameset,time.s, Ts, TE, AA, E, qq, conew, mnew, nnew, np, pr, deg,amin,amax,...) {

set_set         <- batchac(time.start=time.s,T0 = Ts, 
							 T.end = TE, A = AA,
							 Ea = E, rates = qq, 
							 co = rep(conew,length(qq)),
							 m = rep(mnew,length(qq)),
							 n = rep(nnew,length(qq)) , 
							 K = 0, npoints = np, 
							 prec = pr, rmod = "SB",...)
					
set_set   	    <- sanitizeForReg(set_set)
set_set_ap      <- peppa(set_set)
dat_set         <- set_set_ap$ap
dat_r           <- set_set_ap$ap

dat_r$eset <- nameset


dat_set$set <- nameset

dat_set$a <- dat_set$alfa/100
dat_set$fan <-   (dat_set$fa)/max(dat_set$fa)
dat_set_sel <- subset(dat_set, (a >=amin & a <=amax))


mylist             <- list("set"=set_set,
						   "dat"=dat_set,
						   "dat_r"=dat_r,
						   "dat_sel"=dat_set_sel)

return(mylist)
}

#+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°
# simulate ground truth and ictac curves and then fit them using nlsLM. it can 
# perform the regression on a set of curves at different rate
#+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°

fitSB  <- function(mat,time.s, Ts, TE, AA, E, qq, np, pr, refMod, mystart,amin,amax,my_step,
					myptol,myftol,coref,...)
{

dat_gt_sel=mat

deg <- seq(amin,amax,my_step)
free_fun <- function(alpha,co,m,n)(co*(alpha^m*(1-alpha)^n))
x_fun <- paste0("function(alpha,m,n)(",coref,"*((alpha^m)*(1-alpha)^n))")
fixed_fun <- eval(parse(text=x_fun))
if (length(mystart) == 3)

 {

#+++++#
#free#
#+++++#
fits <- dat_gt_sel  %>%   group_by(., rate) %>%   nest() %>%
	mutate(fit = purrr::map(data, ~ nlsLM(fan ~ free_fun(a, co, m, n),
                                   data = .x,
                                   start = mystart,jac = NULL,
								   control = nls.lm.control(ftol = myftol,
								   ptol = myptol, gtol = 0, diag = list(), 
								   epsfcn = 0, factor = 100, 
								   maxfev = integer(), maxiter = 1000, nprint = 0), ...)))

}

else {
#+++++#
#fixed#
#+++++#
fits <- dat_gt_sel  %>%   group_by(., rate) %>%   nest() %>%
	mutate(fit = purrr::map(data, ~ nlsLM(fan ~ fixed_fun(a, m, n),
                                   data = .x,
                                   start = mystart,jac = NULL,
								   control = nls.lm.control(ftol = myftol,
								   ptol = myptol, gtol = 0, diag = list(), 
								   epsfcn = 0, factor = 100, 
								   maxfev = integer(), maxiter = 1000, nprint = 0), ...)))
		#select(fits, rate, data, fit)
		#summary(fits$fit[[1]])
		#lower = c(m = 0.2, n=0.2)
}
		
info <- fits %>%   mutate(summary = map(fit, glance)) %>%   unnest(summary)
# get params
params <- fits %>%   mutate(., p = map(fit, tidy)) %>%   unnest(p)
# get confidence intervals

if (length(mystart) == 3)
 {
  CI <- fits %>%   mutate(., cis = map(fit, confint2), cis = map(cis, data.frame)) %>%   unnest(cis) %>%   rename(., conf.low = X2.5.., conf.high = X97.5..) %>%   group_by(., rate) %>%   mutate(., term = c('co', 'm', 'n')) %>% 
  ungroup() 
}
else
 {
	CI <- fits %>%   mutate(., cis = map(fit, confint2), cis = map(cis, data.frame)) %>%   unnest(cis) %>%   rename(., conf.low = X2.5.., conf.high = X97.5..) %>%   group_by(., rate) %>%   mutate(., term = c('m', 'n')) %>% 
    ungroup() 
}
# merge parameters and CI estimates
params <- merge(params, CI, by = intersect(names(params), names(CI)))
# get predictions
preds <- fits %>%   mutate(., p = map(fit, augment)) %>%   unnest(p) 
dtPar <- data.table(params)
selcols <- c("rate","term","estimate")
dtpar <- dtPar[, ..selcols]
dtpar <- dtpar[order(dtpar$rate),]
colstab <- c("rate","term","estimate","std.error","statistic","p.value","conf.low","conf.high")
partab <- dtPar[, ..colstab]
partab <- partab[order(partab$rate),]

if (length(mystart) == 3)
	 {
	  dtco <- dtpar[term=="co"]
	 }

dtm  <- dtpar[term=="m"]
dtn  <- dtpar[term=="n"]

if (length(mystart) == 3)
	 {
	 co_fit <- dtco$estimate
	 }
 else
	 {
	 co_fit <- rep(coref,length(qq))
	 }
m_fit  <- dtm$estimate
n_fit  <- dtn$estimate

test <- create_set("test",time.s, Ts, TE, AA, E, qq, conew = co_fit, mnew = m_fit, nnew = n_fit, np, pr,amin = amin,amax = amax,...) 

dat_fit <- test$dat
dat_fit$a <- dat_fit$alfa/100
dat_fit$fan <-   (dat_fit$fa)/max(dat_fit$fa)

dat_fit_sel <- dat_fit[,c("id_cycle","id"):=NULL]
dat_fit_sel$set <- "fit"
dat_gt_sel$set <- "reference"

dat_fit_sel$id_cycle <- dat_fit$rate
EA_free        <- batchtriplet(dat_fit_sel,mydegree=deg)

mylist <- list("dat_fit_sel"=dat_fit_sel,
			   "parameters_free"=partab,
			   "EA"=EA_free,
			   "params"=params,
			   "preds"=preds)
}

#+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°

sreg <- function(nameset="set",time_start,
							   Temp_start,
							   Temp_End,
							   A,Ea,rate,
							   number_of_points,
							   precision_start,
							   referenceMod,
							   alfa_degree,
							   alfa_min,
							   alfa_max,
							   co_reference,
							   m_reference,
							   n_reference,
							   fitted_co,fitted_m,fitted_n,...){
#++++++++++++++++++++++++++++
gt_set <- create_set_gt(time.s=time_start,
						Ts=Temp_start,
						TE=Temp_End,
						AA=A,	E=Ea, qq=rate,
						np=number_of_points,
						pr=precision_start,
						refMod=referenceMod,
						deg=alfa_degree,
						amin=alfa_min,
						amax=alfa_max,...)
ictac_set <- create_set("ictac",
						 time.s=time_start,
						 Ts=Temp_start,
						 TE=Temp_End,
						 AA=A,
						 E=Ea,
						 qq=rate,
						 conew=co_reference,
						 mnew=m_reference,
						 nnew=n_reference,
						 np=number_of_points,
						 pr=precision_start,
						 deg=alfa_degree,
						 amin=alfa_min,
						 amax=alfa_max,...)
#++++++++++++++++++++++++++++


gt_set$dat_gt$id_cycle <- gt_set$dat_gt$rate
EA_gt_t      <- batchtriplet(gt_set$dat_gt,
							 mydegree=alfa_degree,...)
EA_gt		 <- EA_gt_t$EA
ictac_set$dat_gt$id_cycle <- ictac_set$dat_gt$rate

EA_ictac_t   <- batchtriplet(ictac_set$dat,
							 mydegree=alfa_degree,...)
EA_ictac	 <- EA_ictac_t$EA
mat <- gt_set$dat_gt_sel
new_set <- create_set(nameset=nameset,
					  time.s=time_start,
					  Ts=Temp_start,
					  TE=Temp_End,
					  AA=A,
					  E=Ea,
					  qq=rate,
					  conew=fitted_co,
					  mnew=fitted_m,
					  nnew=fitted_n,
					  np=number_of_points,
					  pr=precision_start,
					  deg=alfa_degree,
					  amin=alfa_min,
					  amax=alfa_max,...)
					  
new_set$dat_sel$id_cycle <- new_set$dat_sel$rate
EA_newset_t   <- batchtriplet(new_set$dat_sel,
							  mydegree=alfa_degree,...)
EA <- EA_newset_t$EA 
mylist <- list("gt"=gt_set,"ictac"=ictac_set,"new_set" = new_set ,"EA_gt"=EA_gt,"EA_ictac"=EA_ictac,"EA"=EA)
return(mylist)
}



pepper <- function(outreg,nameset="newset"){
outreg_EA     <- outreg$EA
outreg_EA_gt     <-  outreg$EA_gt
outreg_EA_ictac  <-  outreg$EA_ictac
outreg_EA$reg    <- "new_reg"
outreg_EA_gt$reg <- "ground_truth"
outreg_EA_ictac$reg <- "ictac"
outreg_E  <- rbind(outreg_EA_gt,outreg_EA_ictac,outreg_EA)
outreg_E$set <- nameset

outreg_E_melt <- melt(outreg_E,id.vars=c("degree","reg","set"))

metrics_ictac         <- fitEA(outreg_EA_gt,outreg_EA_ictac)
metrics_new_reg       <- fitEA(outreg_EA_gt,outreg_EA)
metrics_ictac$reg     <- "ictac"
metrics_new_reg$reg   <- "new_reg"
outreg_metrics        <- rbind(metrics_ictac,metrics_new_reg)
outreg_metrics$set    <- nameset

outreg_gt           <-  outreg$gt$dat_gt
outreg_gt$id        <- outreg_gt$id_cycle
outreg_ictac        <-  outreg$ictac$dat
outreg_new_set      <-  outreg$new_set$dat
outreg_gt$reg       <- "ground_truth"
outreg_ictac$reg    <- "ictac"
outreg_new_set$reg  <- "new_reg"
out <- rbind(outreg_gt,outreg_ictac,outreg_new_set)

pE <- ggplot(outreg_E_melt, aes(col = reg)) +   geom_line(aes(degree, value)) +   facet_wrap(~ variable, scale = 'free_x', ncol = 4)
pmetrics <- ggplot(A2_metrics, aes(col = reg)) +   geom_point(aes(metrics, value)) +   facet_wrap(~ method, scale = 'free_x', ncol = 4)
pheat <- ggplot(out, aes(col = reg)) +   geom_line(aes(temperature.s, heat.flow)) +   facet_wrap(~ rate, scale = 'free_x', ncol = 7)
pfa   <- ggplot(out, aes(col = reg)) +   geom_line(aes(ri, fa)) +   facet_wrap(~ rate, scale = 'free_x', ncol = 7)
mylist <- list("E"=outreg_E, "E_melt"=outreg_E_melt,"metrics"=outreg_metrics,"dat"=out,"pE"=pE,"pheat"=pheat,"pfa"=pfa)
return(mylist)
}

sreg <- function(nameset="set",time_start,
							   Temp_start,
							   Temp_End,
							   A,Ea,rate,
							   number_of_points,
							   precision_start,
							   referenceMod,
							   alfa_degree,
							   alfa_min,
							   alfa_max,
							   co_reference,
							   m_reference,
							   n_reference,
							   fitted_co,fitted_m,fitted_n,...){
#++++++++++++++++++++++++++++
gt_set <- create_set_gt(time.s=time_start,
						Ts=Temp_start,
						TE=Temp_End,
						AA=A,	E=Ea, qq=rate,
						np=number_of_points,
						pr=precision_start,
						refMod=referenceMod,
						deg=alfa_degree,
						amin=alfa_min,
						amax=alfa_max,...)
ictac_set <- create_set("ictac",
						 time.s=time_start,
						 Ts=Temp_start,
						 TE=Temp_End,
						 AA=A,
						 E=Ea,
						 qq=rate,
						 conew=co_reference,
						 mnew=m_reference,
						 nnew=n_reference,
						 np=number_of_points,
						 pr=precision_start,
						 deg=alfa_degree,
						 amin=alfa_min,
						 amax=alfa_max,...)
#++++++++++++++++++++++++++++


gt_set$dat_gt$id_cycle <- gt_set$dat_gt$rate
EA_gt_t      <- batchtriplet(gt_set$dat_gt,
							 mydegree=alfa_degree,...)
EA_gt		 <- EA_gt_t$EA
ictac_set$dat_gt$id_cycle <- ictac_set$dat_gt$rate

EA_ictac_t   <- batchtriplet(ictac_set$dat,
							 mydegree=alfa_degree,...)
EA_ictac	 <- EA_ictac_t$EA
mat <- gt_set$dat_gt_sel
new_set <- create_set(nameset=nameset,
					  time.s=time_start,
					  Ts=Temp_start,
					  TE=Temp_End,
					  AA=A,
					  E=Ea,
					  qq=rate,
					  conew=fitted_co,
					  mnew=fitted_m,
					  nnew=fitted_n,
					  np=number_of_points,
					  pr=precision_start,
					  deg=alfa_degree,
					  amin=alfa_min,
					  amax=alfa_max,...)
					  
new_set$dat_sel$id_cycle <- new_set$dat_sel$rate
EA_newset_t   <- batchtriplet(new_set$dat_sel,
							  mydegree=alfa_degree,...)
EA <- EA_newset_t$EA 
mylist <- list("gt"=gt_set,"ictac"=ictac_set,"new_set" = new_set ,"EA_gt"=EA_gt,"EA_ictac"=EA_ictac,"EA"=EA)
return(mylist)
}

#+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°
# simple nls regression with SB method for a single  curve
#+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°


sfitSB  <- function(nameset="test",mat,time.s, Ts, TE, AA, E, qq, np, pr, refMod, mystart,amin,amax,my_step,coref,...)
{

deg <- seq(amin,amax,my_step)
free_fun <- function(a,co,m,n)(co*(a^m*(1-a)^n))
x_fun <- paste0("function(a,m,n)(",coref,"*((a^m)*(1-a)^n))")
fixed_fun <- eval(parse(text=x_fun))
dfxy <- data.frame(mat$a,mat$fan)
colnames(dfxy)= c("a","fan")

if (length(mystart) == 3)

 {

#+++++#
#free#
#+++++#

mod_fit <- nlsLM(fan~free_fun(a,co,m,n),start=mystart,data=dfxy)
fit_co <- summary(mod_fit)$coeff[1]
fit_m  <- summary(mod_fit)$coeff[2]
fit_n  <- summary(mod_fit)$coeff[3]
colist=list("co"=fit_co,"m"=fit_m,"n"=fit_n)
test <- create_set(nameset,time.s, Ts, TE, AA, E, qq, conew = fit_co, mnew = fit_m, nnew = fit_n, np, pr,amin = amin,amax = amax,...) 

}

else {
#+++++#
#fixed#
#+++++#

mod_fit <- nlsLM(fan~fixed_fun(a,m,n),start=mystart,data=dfxy)
fit_m  <- summary(mod_fit)$coeff[2]
fit_n  <- summary(mod_fit)$coeff[3]
colistlist("co"=coref,"m"=fit_m,"n"=fit_n)
test <- create_set(nameset,time.s, Ts, TE, AA, E, qq, conew = coref, mnew = fit_m, nnew = fit_n, np, pr,amin = amin,amax = amax,...) 

}

dat_fit <- test$dat
mylist <- list("dat_fit"=dat_fit,"coeff"=colist,"mod_fit"=mod_fit)
}



#+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°
# plot
#+++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°


#++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°
#++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°
#++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°
# From this point all the function are related to presenting the data
# mainly they take the data table given as output by the simmy function
# and prepares tables (for xls export) and plots
#++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°
#++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°
#++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°

fitEA <- function(EAref,EAout,nameset="out",low=0.05,high=0.95){

EAref  <-  subset(EAref, (degree >= low & degree <= high))
EAout  <-  subset(EAout, (degree >= low & degree <= high))
cR2     <-  c(R2(EAref$Friedman,EAout$Friedman),R2(EAref$KAS,EAout$KAS),R2(EAref$Starink,EAout$Starink))
cRMSE   <-  c(RMSE(EAref$Friedman,EAout$Friedman),RMSE(EAref$KAS,EAout$KAS),RMSE(EAref$Starink,EAout$Starink))
cMAE    <-  c(MAE(EAref$Friedman,EAout$Friedman),MAE(EAref$KAS,EAout$KAS),MAE(EAref$Starink,EAout$Starink))

lab_methods <- c("Friedman","KAS","Starink")

df_RMSE <- data.frame(cRMSE,lab_methods)
df_MAE  <- data.frame(cMAE,lab_methods)
df_R2   <- data.frame(cR2 ,lab_methods)

df_R2$set   <- nameset
df_MAE$set  <- nameset
df_RMSE$set <- nameset

colnames(df_RMSE) <- c("value","method","metrics")
colnames(df_MAE) <- c("value","method","metrics")
colnames(df_R2) <- c("value","method","metrics")

df_R2$metrics  <- "R2"
df_MAE$metrics  <- "MAE"
df_RMSE$metrics  <- "RMSE"

df_met <- rbind(df_R2,df_MAE,df_RMSE)
return(df_met)

}

# wrapApprox <- function(x,y,xout,...){yout <-approx(x,y,xout,...)
									 # return(yout$y)}

#++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°
# PLOT 
#++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°




pepper <- function(outreg,nameset="newset"){
outreg_EA     <- outreg$EA
outreg_EA_gt     <-  outreg$EA_gt
outreg_EA_ictac  <-  outreg$EA_ictac
outreg_EA$reg    <- "new_reg"
outreg_EA_gt$reg <- "ground_truth"
outreg_EA_ictac$reg <- "ictac"
outreg_E  <- rbind(outreg_EA_gt,outreg_EA_ictac,outreg_EA)
outreg_E$set <- nameset

outreg_E_melt <- melt(outreg_E,id.vars=c("degree","reg","set"))

metrics_ictac         <- fitEA(outreg_EA_gt,outreg_EA_ictac)
metrics_new_reg       <- fitEA(outreg_EA_gt,outreg_EA)
metrics_ictac$reg     <- "ictac"
metrics_new_reg$reg   <- "new_reg"
outreg_metrics        <- rbind(metrics_ictac,metrics_new_reg)
outreg_metrics$set    <- nameset

outreg_gt           <-  outreg$gt$dat_gt
outreg_gt$id        <- outreg_gt$id_cycle
outreg_ictac        <-  outreg$ictac$dat
outreg_new_set      <-  outreg$new_set$dat
outreg_gt$reg       <- "ground_truth"
outreg_ictac$reg    <- "ictac"
outreg_new_set$reg  <- "new_reg"
out <- rbind(outreg_gt,outreg_ictac,outreg_new_set)


pE <- ggplot(outreg_E_melt, aes(col = reg)) +   geom_line(aes(degree, value)) +   facet_wrap(~ variable, scale = 'free_x', ncol = 4)
pmetrics <- ggplot(outreg_metrics, aes(col = reg)) +   geom_point(aes(metrics, value)) +   facet_wrap(~ method, scale = 'free_x', ncol = 4)
pheat <- ggplot(out, aes(col = reg)) +   geom_line(aes(temperature.s, heat.flow)) +   facet_wrap(~ rate, scale = 'free_x', ncol = 7)
pfa   <- ggplot(out, aes(col = reg)) +   geom_line(aes(ri, fa)) +   facet_wrap(~ rate, scale = 'free_x', ncol = 7)
mylist <- list("E"=outreg_E, "E_melt"=outreg_E_melt,"metrics"=outreg_metrics,"dat"=out,"pE"=pE,"pheat"=pheat,"pfa"=pfa,"pmetrics"=pmetrics)
return(mylist)
}

plotCoeff <- function(out){

params <- out$params
preds  <- out$preds
p <- ggplot(params, aes(col = as.factor(rate))) +   geom_point(aes(rate, estimate)) +
      facet_wrap(~ term, scale = 'free_x', ncol = 4) +   geom_linerange(aes(rate, ymin = conf.low, ymax = conf.high)) +
      coord_flip() +   theme(legend.position = 'top') +   xlab('curve') +   ylab('parameter estimate')
mylist <-list("p"=p)
return(mylist)
}

#++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°
# functions to export XLS 
#++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°+++++++++°

#write metric mat
#writeData(wb,namesheet,df_met,startCol =1 , startRow = 1)

xlsDumpDAT <-  function(wb, dat ,nameset="myset",namereg="namereg",space=5) {
colnames(dat)[colnames(fit) == 'dadT'] <- 'dadTemperature'
regsheet <- paste0(nameset,namereg)
addWorksheet(wb,regsheet)
}

xlsCoeff <-  function(wb, namesheet, output,space=5,startpos=1) {
addWorksheet(wb,namesheet)
params_fit    <- output$params 
label_params_fit     <- data.frame("params_fit")
ix1 <- dim(params_fit )[1] + space
#params_fit
writeData(wb,namesheet,label_params_fit, startCol=1, startRow = 1+startpos)
writeData(wb,namesheet,params_fit,       startCol=1, startRow = 3+startpos)
}

xlsMatRes <-  function(wb, mat ,nameset="myset") {
fitsheet <- paste0(nameset,"resampled")
colnames(mat)[colnames(mat) == 'dadT'] <- 'dadTemperature'
#set_fit
writeData(wb,fitsheet,fit,startRow=1,startCol=1)
}
